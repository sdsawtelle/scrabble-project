from __future__ import division

""" The purpose of this script is to use the Official Word List (OWL3) to generate a set of word lists that are useful
on a scrabble cheat sheet. This file relies on reading in the full OWL3 dictionary that was generated by
dictionary-maker.py from a set of sources
"""

import os  # access to systems primitives

__author__ = 'Sonya'
__email__ = "sdsawtelle@gmail.com"
__version__ = "2.7.8"


# First change the working directory to the hardcoded directory where we will expect to find the OWL3 and to output
# the wordlists we generate.
path = "C:\Users\Sonya\Dropbox\Shared_SDS_WDB\ScrabbleWords"
os.chdir(path)

# Now read in the dictionary to create a list where each element is a word. Readlines returns a list where each
# element is the line of the file, up until EOF is reached.
with open("OWL3_Dictionary.txt") as text:
    dictionary = text.readlines()

# Strip the newline characters from each word and then make sure each word is lower-case.
dictionary = [word.strip('\n\r') for word in dictionary]
dictionary = [word.lower() for word in dictionary]

# Now loop through the dictionary and create a set of more specific lists, to be described below
two_words = []  # all the words of length 2
three_words = []  # all the words of length 3
four_words = []  # all the words of length 4
j_words = []  # all the words containing at least one 'j'
x_words = []  # all the words containing at least one 'x'
q_words = []  # all the words containing at least one 'q'
z_words = []  # all the words containing at least one 'z'

for word in dictionary:
    if len(word) == 2:
        two_words.append(word)
    elif len(word) == 3:
        three_words.append(word)
    elif len(word) == 4:
        four_words.append(word)

    # The "in" operator has implementation for strings, it evaluates true only if a is a substring of b (and it is
    # case sensitive)
    if "j" in word:
        j_words.append(word)
    if "x" in word:
        x_words.append(word)
    if "q" in word:
        q_words.append(word)
    if "z" in word:
        z_words.append(word)


# Now we use the two-letter-words and three-letter-words lists to make an arrray which holds the information about
# what are valid hooks for each two-letter word. This array will consist of a single row for each two-letter word,
# where the row has three elements: the first element is valid prefixes, the second element is the two-letter word
# and the third element is valid suffixes.

# This function will take as an input two lists of words, the first input being the list of smaller-sized words, the
# second being the list of larger sized words. It will output the kind of hook-array described above.
def find_hooks(short_words, long_words):
    hooks_array = []
    for short_word in short_words:
        prefixes = [long_word.replace(short_word, "") for long_word in long_words if short_word == long_word[1:]]
        suffixes = [long_word.replace(short_word, "") for long_word in long_words if short_word == long_word[0:-1]]
        hooks_array.append([prefixes, short_word.upper(), suffixes])
    return hooks_array

# Now use this function to create the hook arrays for two and three letter words.
two_to_make_threes = find_hooks(two_words, three_words)
three_to_make_fours = find_hooks(three_words, four_words)


# The above arrays are nice to have in case we ever want to manipulate this information to make e.g. a game for
# learning the hooks. For now though we want to output them in a text file in a way that takes up as little space as
# possible. For this reason the prefixes will be collapsed into a string, and likewise for the suffixes. I'll define
# a function that prettifies the hook arrays and outputs them to the text file
def print_hooks(filepath, hook_array):
    with open(filepath, 'w') as text:
        # The join method for string has implementation where it concatenates all the string elements in the sequence by
        # gluing them together with the string on which the method is called.
        compressed_array = ["".join(row[0]) + " " + row[1] + " " + "".join(row[2]) for row in hook_array]
        text.writelines(["%s\n" % row for row in compressed_array])


print_hooks(path + "\Two_to_Make_Threes.txt", two_to_make_threes)
print_hooks(path + "\Threes_to_Make_Fours.txt", three_to_make_fours)


# Now we will cull the X, J and Z lists to be only length five or less, and sort them by length and then as a second
# step alphabetize within each length. I will write a function to do these steps, as well as writing the list to file.
def pointer_lists(wordlist, filepath):
    shortlist = [word for word in wordlist if len(word) <= 5]
    # The default sort behavior for a list of strings is alphabetical, and for a list of numbers it is exactly what you
    # would expect. The default sort behavior for a list of lists is to sort on elements at the first index, then second
    # etc. So we can define our sorting key to take in a word and spit out a list where the first element is length of
    # word and the second element is the word itself. This will give us heirarchical sorting by length then alphabetical
    shortlist.sort(key=lambda item: (len(item), item))

    # Now we need to print this list to a file.
    with open(filepath, 'w') as text:
        text.writelines(["%s\n" % word for word in shortlist])

    # print "Number of words in " + filepath + " is " + str(len(shortlist)) + " and without 5-letter words it is " +
    # str(len([word for word in shortlist if len(word) < 5]))

    # Return the finalized list in case we want it later.
    return shortlist

# Now we make all our lists :)
pointer_lists(j_words, path + "\Short_J_Words.txt")
pointer_lists(x_words, path + "\Short_X_Words.txt")
pointer_lists(z_words, path + "\Short_Z_Words.txt")
pointer_lists(q_words, path + "\Short_Q_Words.txt")


# Now we want to make a list that is Q words that have no "u" in them! There are not many of these so we will not
# restrict to length five.
ulesslist = [word for word in q_words if "u" not in word]
ulesslist.sort(key=lambda item: (len(item), item))
# And we need to print this list to a file.
with open(path + "\Q_without_U_Words.txt", 'w') as text:
    text.writelines(["%s\n" % word for word in ulesslist])


# Now we would like to make a "Vowel Dump" list. This is a list of words whose length is five or less and which contain
# at least 75% vowels. That means for a two or three-letter word it must be all vowels For a four-letter word it must be
# three vowels and a consonant. And for a five letter word it must be four vowels and a consonant. We will then want to
# make specific "I" dumps and "U" dumps which are defined as words containing at least 66% "U"s or "I"s respectively.
# For this reason we will define a somewhat general function that tells you whether the fractional content of specific
# character is above a certain threshold for any word. For instance in making the vowel dump list the key characters
# will be "a" "e" "i" "o" and "u" and the threshold will be 75%.


# We define a boolean function that determines if the percentage of characters which are in a "match list" in a
# given word is greater than or equal to a certain percentage (which is an input parameter)
def wordcontent(word, matchlist, minfraction):
    # Turn word from a list of chars into a list of bools according to whether each char is in the match list
    matches = [(char in matchlist) for char in word]

    # Compute percentage of characters matching the "match list" by adding the "1"s in the above list
    percentage = sum(matches)/len(word)
    return True if percentage >= minfraction else False


# Now we go through the dictionary and pull out only words have 75% or more vowels and are length five or less, and
# finally sort by length and then alphabetical.
vowels = ["a", "e", "i", "o", "u"]
voweldump = [word for word in dictionary if wordcontent(word, vowels, 0.75) and len(word) <= 5]
voweldump.sort(key=lambda item: (len(item), item))
# Finally, we print out this voweldump list!
with open(path + "\Vowel_Dumps.txt", 'w') as text:
    text.writelines(["%s\n" % word for word in voweldump])


# A "U" Dump or an "I" Dump wil be defined as a word that contains at least two thirds "U" or "I", respectively. We want
# a list of these words. We can reuse the wordcontent function we wrote above, but now the match list is just a single
# character.
idump = [word for word in dictionary if wordcontent(word, "i", 0.50) and len(word) > 2]
idump.sort(key=lambda item: (len(item), item))
# Finally, we print out this i-dump list!
with open(path + "\I_Dumps.txt", 'w') as text:
    text.writelines(["%s\n" % word for word in idump])


udump = [word for word in dictionary if wordcontent(word, "u", 0.50) and len(word) > 2]
udump.sort(key=lambda item: (len(item), item))
# Finally, we print out this u-dump list!
with open(path + "\U_Dumps.txt", 'w') as text:
    text.writelines(["%s\n" % word for word in udump])


print